IO网络编程
Tedu Python 教学部
Author：吕泽
Days：3天

    • IO
    • 文件
        ◦ 字节串（bytes）
        ◦ 文件读写
            ▪ @ 扩展延伸：文件流
        ◦ 其他操作
            ▪ 刷新缓冲区
            ▪ 文件偏移量
            ▪ 文件描述符
        ◦ 文件管理函数
    • 网络编程基础
        ◦ OSI七层模型
        ◦ 四层模型（TCP/IP模型）
            ▪ 数据传输过程
            ▪ 网络协议
        ◦ 网络基础概念
    • 传输层服务
        ◦ 面向连接的传输服务（基于TCP协议的数据传输）
        ◦ 面向无连接的传输服务（基于UDP协议的数据传输）
    • socket套接字编程
        ◦ 套接字介绍
        ◦ tcp套接字编程
            ▪ 服务端流程
            ▪ 客户端流程
            ▪ tcp 套接字数据传输特点
            ▪ 网络收发缓冲区
            ▪ tcp粘包
        ◦ UDP套接字编程
            ▪ 服务端流程
            ▪ 客户端流程
        ◦ socket模块方法和socket套接字属性
        ◦ UDP套接字广播
        ◦ TCP套接字之HTTP传输
            ▪ HTTP协议 （超文本传输协议）
            ▪ HTTP请求
            ▪ http响应（response）
    • struct模块的使用
前情回顾

1. 二叉树的层次遍历
2. 算法基础
3. 排序 ： 冒泡  选择   插入   快速
4. 查找 ： 二分查找

(book:数据结构python实现, 算法导论)
(公众号： 算法爱好者，python程序员，python开发者)
(app: 掘金，知乎)

5. 什么是IO
6. 字节串和字符串之间的转换

******************************************************

文件读写流程

1. open 打开文件
2. 读写文件
3. close 关闭文件

读操作

read([size])
1. 如果不加参数表示读到文件末尾，如果文件过大时不建议这样做，会消耗大量内存，读取时间也会更长
2. 如果读取到文件结尾再读取会得到空字符串
3. 实际读取到的内容可能小于等于指定的size大小

readline([size])
1.每次读取一行内容遇到换行终止
2.如果指定size，则只读取size大小的内容

readlines([size])
1. 读取到整行内容作为列表返回，每行是列表中一个元素
2. 如果写size，size不足一行也会得到整行内容

write(string)
1. 如果想换行需要人为添加换行符


注意：
如果open打开文件的方式中有b，表示以二进制打开，此时读写操作得到或者写入的内容都是字节串

缓冲区： 减少和磁盘的交互次数，提高磁盘读写效率

1. buffer = 1 表示行缓存则在写入数据时遇到\n自动刷新缓冲区
2. 采用系统默认缓存需要缓冲区满后才能自动写入磁盘

3. 无论什么缓冲，当程序结束或者文件被关闭时都会将缓冲区内容写入磁盘

4. 通过调用flush()可以人为刷新缓冲


文件偏移量

功能： 代表文件的当前读写操作位置，随读写操作移动

1. r，w方式打开文件此时偏移量在开头
2. 以a 方式打开此时偏移量在末尾

文件描述符：

系统为每个IO操作分配的整数，不会重复


网络编程
IO
    1. 定义
在内存中存在数据交换的操作认为是IO操作,比如和终端交互 ,和磁盘交互，和网络交互等
    2. 程序分类
    • IO密集型程序：在程序执行中有大量IO操作，而cpu运算较少。消耗cpu较少，耗时长。
    • 计算密集型程序：程序运行中计算较多，IO操作相对较少。cpu消耗多，执行速度快，几乎没有阻塞。
文件
文件是保存在持久化存储设备(硬盘、U盘、光盘..)上的一段数据。从功能角度分为文本文件（打开后会自动解码为字符）、二进制文件(视频、音频等)。在Python里把文件视作一种类型的对象，类似之前学习过的其它类型。
字节串（bytes）
在python3中引入了字节串的概念，与str不同，字节串以字节序列值表达数据，更方便用来处理二进程数据。因此在python3中字节串是常见的二进制数据展现方式。
    • 普通的ascii编码字符串可以在前面加b转换为字节串，例如：b'hello'
    • 字符串转换为字节串方法 ：encode()
    • 字节串转换为字符串方法 : decode()
s = input(">>")

#　字符串 --> 字节串
byte = s.encode()
print("bytes:",byte)

#　字节串 --> 字符串
s = byte.decode()
print("str:",s)

#　打印字节串
print("bytes:",b"hello world")

# 通过字节串转换函数转换为字节串
print("int :",bytes('abc',encoding='utf-8'))
文件读写
对文件实现读写的基本操作步骤为：打开文件，读写文件，关闭文件
代码实现： day1/file_open.py
#　文件操作示例
# 打开文件
try:
    fd = open("test",'a')
except FileNotFoundError as e:
    print(e)
else:
    print("打开文件成功")


# 关闭文件
fd.close()
代码实现： day1/file_read.py
#　文件操作示例
# 打开文件
try:
    fd = open("test",'a')
except FileNotFoundError as e:
    print(e)
else:
    print("打开文件成功")
# 开始你的读写操作
# 关闭文件
fd.close()
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#　二进制文件读操作
#　以二进制方式打开
fd = open('img.jpg','rb')
data = fd.read() #　得到字节串
print(data)
fd.close()
代码实现： day1/file_write.py

#　二进制文件写操作
#　以二进制方式打开
fd = open('test','wb')
fd.write(b"hello world") #　必须写入字节串
fd.close()
#　文件的读操作演示
import time

#　打开文件返回文件对象
fd = open('test','r')

#　读操作
# while True:
#     #　每次读取８字节
#     data = fd.read(8)
#     #　如果读到空表示文件已经读完
#     if not data:
#         break
#     print("读取到的内容：",data)

#　读取一行内容
# data = fd.readline()
# print("读取到的内容：",data)

#　将读取内容作为列表返回
# data = fd.readlines()
# print("读取到的内容：",data)

#　ｆｄ为可迭代对象，使用for循环每次获取一行内容
for line in fd:
    print("每行内容：", line)

# 关闭文件
fd.close()


代码开始：
fd = open('test','a')
#　写操作
fd.write('hello　死鬼\n')
fd.write('干啥呀')
# 写入一个列表内容
# fd.writelines(['hello\n','world\n'])
fd.close()
    1. 打开文件
file_object = open(file_name, access_mode='r', buffering=-1)
功能：打开一个文件，返回一个文件对象。
参数：file_name————文件名；
     access_mode————打开文件的方式,如果不写默认为‘r’ 
          文件模式                        操作
              r                    以读方式打开 文件必须存在
              w                    以写方式打开
                                   文件不存在则创建，存在清空原有内容 
              a                    以追加模式打开 
              r+                   以读写模式打开 文件必须存在
              w+                   以读写模式打开文件
                                   不存在则创建，存在清空原有内容
              a+                   以读写模式打开 追加模式
              rb                   以二进制读模式打开 同r
              wb                   以二进制写模式打开 同w
              ab                   以二进制追加模式打开 同a
              rb+                  以二进制读写模式打开 同r+
              wb+                  以二进制读写模式打开 同w+
              ab+                  以二进制读写模式打开 同a+
     buffering————参数0表示无缓冲，1表示有行缓冲，如果是大于1标识直接指明缓冲区大小。如果不写或为负数则表示使用系统默认提供的缓冲机制。
返回值：成功返回文件流对象。失败得到IOError。
缓冲:系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，装满缓冲区在一起送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区逐个的将数据送到程序的数据区。

@ 扩展延伸：文件流
代码实现： day1/stdin.py
流（stream）：所有的I/O操作仅是简单的从程序移进或者移出，这种字节流，就称为流。所以打开一个文件有时也称为打开一个文件流对象
系统已经默认为我们打开了三个流，在sys模块中：
标准输入————sys.stdin
标准输出————sys.stdout
标准错我————sys.stderr

    1. 读取文件
read([size])
用来直接读取字节到字符串中，最多读取给定数目个字节。如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾。文件过大时候建议在non-blocking模式下使用。
readline([size])
读取打开文件的一行(读取下个行结束符之前的所有字节)。然后整行，包括行结束符，作为字符串返回。和 read() 相同，它也有一个可选的 size 参数，默认为 -1，代表读至行结束符。如果提供了该参数，那么在超过size个字节后会返回不完整的行。
readlines([sizeint])
该方法并不像其它两个输入方法一样返回一个字符串。它会读取所有(剩余的)行然后把它们作为一个字符串列表返回。它的可选参数sizhint代表返回的最大字节大小。
文件对象本身也是一个迭代器，在for循环中可以迭代文件的每一行。
for line in f:
     print(line)
    3. 写入文件
write(string)
功能与 read() 和 readline() 相反。它把含有文本数据或二进制数据块的字符串写入到文件中去。
writelines(str_list)
和 readlines() 一样，writelines()方法是针对列表的操作，它接受一个字符串列表作为参数，将它们写入文件。行结束符并不会被自动加入，所以如果需要的话，你必须在调用writelines()前给每行结尾加上行结束符。
    4. 关闭文件
打开一个文件后我们就可以通过文件对象对文件进行操作了，当操作结束后使用close（）关闭这个对象可以防止一些误操作，也可以节省资源。
file_object.close()
    5. with操作
python中的with语句使用于对资源进行访问的场合，保证不管处理过程中是否发生错误或者异常都会执行规定的“清理”操作，释放被访问的资源，比如有文件读写后自动关闭、线程中锁的自动获取和释放等。
with语句的语法格式如下：
with context_expression [as target(s)]:
    with-body
通过with方法可以不用close(),因为with生成的对象在语句块结束后会自动处理，所以也就不需要close了，但是这个文件对象只能在with语句块内使用。
with open('file','r+') as f:
    f.read()

# ｗｉｔｈ语句
with open('test') as f:  #　生成文件对象
    data = f.read()
    print(data)
#语句块结束　ｗｉｔｈ生成的对象ｆ会被自动释放
其他操作
刷新缓冲区

代码实现： day1/flush.py
flush()
该函数调用后会进行一次磁盘交互，将缓冲区中的内容写入到磁盘。

#　缓冲区示例

# fd = open('test','w',0) #　无缓冲 (pycharm不允许)
# fd = open('test','w',1) #　行缓冲
# fd = open('test','w',12) #　指名缓冲区大小(不识别)
fd = open('test','w') # 系统默认缓冲区的大小

while True:
    s = input(">>")
    fd.write(s)
    fd.flush() #　立即刷新缓冲,将内容写入磁盘

fd.close()
文件偏移量
代码实现： day1/seek.py
    1. 定义
打开一个文件进行操作时系统会自动生成一个记录，记录中描述了我们对文件的一系列操作。其中包括每次操作到的文件位置。文件的读写操作都是从这个位置开始进行的。
    2. 基本操作
tell()
功能：获取文件偏移量
seek(offset[,whence])
功能:移动文件为止
参数：offset字节代表相对于某个位置偏移量。可以是负数表示向前移动。
whence是基准位置的默认值为 0，代表从文件开头算起，1代表从当前位置算起，2 代表从文件末尾算起。


# 文件偏移量示例

fd = open('test','r+')

#　相对开头位置向后偏移了多少
print("当前文件偏移量位置：",fd.tell()) #0
print(fd.read(2))
print("当前文件偏移量位置：",fd.tell()) #2

#　人为调整文件偏移
fd.seek(5,0) #　相对开头位置向后偏移5个
print(fd.read(2))


fd.close()
文件描述符
    1. 定义
系统中每一个IO操作都会分配一个整数作为编号，该整数即这个IO操作的文件描述符。
    2. 获取文件描述符
fileno()
通过IO对象获取对应的文件描述符
文件管理函数
    1. 获取文件大小
os.path.getsize(file)(使用前都需要import os）
    2. 查看文件列表
os.listdir(dir)
    4. 查看文件是否存在
os.path.exists(file)
    5. 判断文件类型
os.path.isfile(file)
    6. 删除文件
os.remove(file)
7 文件复制
要求：从终端运行后，输入想要复制的文件名，内容复制到myfile文件中从终端输入一个文件名称（可以夹带路径），将该文件复制到当前目录下，并且重名为 xxxx .要求可以复制所有类型文件
filename = input("Filename:") #　
try:
    fr = open(filename,'rb')
except FileNotFoundError as e:
    print(e)
else:
    fw = open('myfile','wb')

    #　循环读取文件内容写入到ｍｙｆｉｌｅ文件#循环读取只是为了装b。直接读就可以了
    while True:
        data = fr.read(1024)
        #　读到文件结尾
        if not data:
            break
        fw.write(data)

    fr.close()
    fw.close()






练习 ： 在text文件里每隔一秒打印一个时间，时间前面标出索引。
import time
fd = open("text", "r+")
size=len(fd.readlines())
i=size+1
try:
    while True:
        a = time.localtime(time.time())
        time01 = time.strftime("%Y-%m-%d %H:%M:%S", a)
        fd.write("%d.%s\n"%(i,time01))
        time.sleep(1)
        i=i+1
except KeyboardInterrupt as e:
    print(e)
老师代码：
import time

f = open('time.txt','a+')

f.seek(0) #　文件偏移量移动到开头

n = 1
for line in f:
    n += 1

while True:
    time.sleep(1)
    s = "%d.  %s\n"%(n,time.ctime())
    f.write(s)
    f.flush()
    n += 1
网络编程基础
计算机网络功能主要包括实现资源共享，实现数据信息的快速传递。
OSI七层模型
制定组织： ISO（国际标准化组织）
作用：使网络通信工作流程标准化
应用层 ： 提供用户服务，具体功能有应用程序实现
表示层 ： 数据的压缩优化加密
会话层 ： 建立用户级的连接，选择适当的传输服务
传输层 ： 提供传输服务
网络层 ： 路由选择，网络互联
链路层 ： 进行数据交换，控制具体数据的发送
物理层 ： 提供数据传输的硬件保证，网卡接口，传输介质
优点
    1. 建立了统一的工作流程
    2. 分部清晰，各司其职，每个步骤分工明确
    3. 降低了各个模块之间的耦合度，便于开发
四层模型（TCP/IP模型）
背景 ： 实际工作中工程师无法完全按照七层模型要求操作，逐渐演化为更符合实际情况的四层

数据传输过程
    1. 发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送消息包。
    2. 发送的消息经过多个节点（交换机，路由器）传输，最终到达目标主机。
    3. 目标主机由物理层逐层解析首部消息包，最终到应用程序呈现消息。

网络协议
在网络数据传输中，都遵循的规定，包括建立什么样的数据结构，什么样的特殊标志等。
网络基础概念
    • 网络主机（host）
功能：标识一台主机在网络中的位置（地址）
本地地址 ： 'localhost' , '127.0.0.1'
网络地址 ： '172.40.91.185'
自动获取地址： '0.0.0.0'
查看本机网络地址命令： ifconfig
    • IP地址
功能：确定一台主机的网络路由位置
结构
IPv4 点分十进制表示 172.40.91.185 每部分取值范围0--255
IPv6 128位 扩大了地址范围
特殊IP
127.0.0.1 本机测试IP
0.0.0.0 自动获取本机网卡地址
172.40.91.0 通常表示一个网段
172.40.91.1 通常表示一个网关
172.40.91.255 用作广播地址
    • 域名
定义： 给网络服务器地址起的名字
作用： 方便记忆，表达一定的含义
ping [ip] : 测试和某个主机是否联通
    • 端口号（port）
作用：端口是网络地址的一部分，用于区分主机上不同的网络应用程序。
特点：一个系统中的应用监听端口不能重复
取值范围： 1 -- 65535
1--1023 系统应用或者大众程序监听端口
1024--65535 自用端口
传输层服务
面向连接的传输服务（基于TCP协议的数据传输）
    1. 传输特征 ： 提供了可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复。
    2. 实现手段 ： 在通信前需要建立数据连接，通信结束要正常断开连接。
三次握手（建立连接）
客户端向服务器发送消息报文请求连接
服务器收到请求后，回复报文确定可以连接
客户端收到回复，发送最终报文连接建立（建立起信息传输的管道）

四次挥手（断开连接）#报文==消息
主动方发送报文请求断开连接
被动方收到请求后，立即回复，表示准备断开
被动方准备就绪，再次发送报文表示可以断开
主动方收到确定，发送最终报文完成断开

    3. 适用情况 ： 对数据传输准确性有明确要求，传数文件较大，需要确保可靠性的情况。比如：网页获取，文件下载，邮件收发。
面向无连接的传输服务（基于UDP协议的数据传输）
    1. 传输特点 ： 不保证传输的可靠性，传输过程没有连接和断开，数据收发自由随意。
    2. 适用情况 ： 网络较差，对传输可靠性要求不高。比如：网络视频，群聊，广播
面试要求
    • OSI七层模型介绍一下，tcp/ip模型是什么？
    • tcp服务和udp服务有什么区别？
    • 三次握手和四次挥手指什么，过程是怎样的？
socket（=接口）套接字编程
套接字介绍
    1. 套接字 ： 实现网络编程进行数据传输的一种技术手段
    2. Python实现套接字编程：import socket
    3. 套接字分类
流式套接字(SOCK_STREAM): 以字节流方式传输数据，实现tcp网络传输方案。(面向连接--tcp协议--可靠的--流式套接字)（水流一样）
数据报套接字(SOCK_DGRAM):以数据报形式传输数据，实现udp网络传输方案。(无连接--udp协议--不可靠--数据报套接字)（打包好的水）
tcp套接字编程
服务端流

代码实现：day2/tcp_server.py
    1. 创建套接字
sockfd=socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=0)
第一个socket是模块名（使用前需要导入），第二个socket是类（可以当成函数看待），括号里的是给类中init方法传递的参数。
模块中全大写的内容可以当成常量内容。
功能：创建套接字
参数：  socket_family： 网络地址类型 AF_INET表示ipv4
        socket_type：  套接字类型 SOCK_STREAM //流式SOCK_DGRAM 数据报
        proto  通常为0表示不选择任何子协议  选择子协议,在应用层中不会用
返回值： 套接字对象
    2. 绑定地址
sockfd.bind(addr)
功能： 绑定本机网络地址
参数： 二元元组 (ip,port)  ('0.0.0.0',8888)建议用一万以上
    3. 设置监听
sockfd.listen(n)
功能 ： 将套接字设置为监听套接字（可同时连接多个客户端，但处理是一个个的，按队列操作），确定监听队列大小。该语句增加的功能：能被客户端连接。
参数 ： 监听队列大小，参数在linux系统下无用
    4. 等待处理客户端连接请求
connfd,addr = sockfd.accept()
功能： 阻塞（input，sleep等函数使得程序暂停执行）等待处理客户端请求
返回值： connfd  客户端连接套接字，专门用来通信，每一个客户端产生一个专门的套接字
         addr  连接的客户端地址
    5. 消息收发
data = connfd.recv(buffersize) conn=connect
功能 : 接受客户端消息
参数 ：每次最多接收消息的大小
返回值： 接收到的内容

n = connfd.send(data)
功能 : 发送消息
参数 ：要发送的内容  bytes格式
返回值： 发送的字节数
    6. 关闭套接字
sockfd.close()
功能：关闭套接字
客户端流程
代码实现：day2/tcp_client.py

    1. 创建套接字
注意:只有相同类型的套接字才能进行通信（流对流，报对报）
    2. 请求连接
sockfd.connect(server_addr)
功能：连接服务器
参数：元组  服务器地址
    3. 收发消息
注意： 防止两端都阻塞，recv send要配合，先收后发对先发后收sock
    4. 关闭套接字
tcp 套接字数据传输特点
    • tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字串。
    • tcp连接中如果一端已经不存在，仍然试图通过send发送则会产生 BrokenPipeError
    • 一个监听套接字可以同时连接多个客户端，也能够重复被连接
网络收发缓冲区
    1. 网络缓冲区有效的协调了消息的收发速度
    2. send和recv实际是向缓冲区发送接收消息，当缓冲区不为空recv就不会阻塞。
tcp粘包
原因：tcp以字节流方式传输，没有消息边界。多次发送的消息被一次接收，此时就会形成粘包。
影响：如果每次发送内容是一个独立的含义，需要接收端独立解析此时粘包会有影响。
处理方法
    1. 人为的添加消息边界
    2. 控制发送速度time.sleep




"""
TCP套接字服务端
重点代码
"""
TCP server
import socket

# create
sockfd = socket.socket(socket.AF_INET, \
                       socket.SOCK_STREAM)

# bind
sockfd.bind(('127.0.0.1', 8880))

# listen
sockfd.listen(5)

# 　accept
while True:
    print("Waiting for connect....")
    try:
        connfd, addr = sockfd.accept()
        print("Connect from:", addr)
    except KeyboardInterrupt:
        print("退出服务")
        break

    # send/receive
    while True:
        data = connfd.recv(1024)
        # 　得到空则退出循环
        if not data:
            break
        print("接收到的消息:", data.decode())
        n = connfd.send(b'Receive your message')
        print("发送了 %d 个字节数据" % n)
    connfd.close()

# close
sockfd.close()

"""
tcp 客户端程序
重点代码
"""
TCP Client
from socket import *

#　创建tcp套接字
sockfd = socket()

#　发起连接
server_addr = ('172.40.91.188',8888)
sockfd.connect(server_addr)

#　收发消息
while True:
    data = input("消息:")
    if not data:
        break
    sockfd.send(data.encode())
    data = sockfd.recv(1024)
    print("From server:",data.decode())

#　关闭
sockfd.close()




UDP套接字编程
服务端流程

代码实现：day2/udp_server.py
    1. 创建数据报套接字
sockfd = socket(AF_INET,SOCK_DGRAM)
    2. 绑定地址
sockfd.bind(addr)
    3. 消息收发
data,addr = sockfd.recvfrom(buffersize)
功能： 接收UDP消息
参数： 每次最多接收多少字节
返回值： data  接收到的内容
        addr  消息发送方地址

n = sockfd.sendto(data,addr)
功能： 发送UDP消息
参数： data  发送的内容 bytes格式
        addr  目标地址
返回值：发送的字节数
    4. 关闭套接字
sockfd.close()
"""
UDP套接字服务端
重点代码
"""

from socket import *

# 　创建数据报套接字
sockfd = socket(AF_INET, SOCK_DGRAM)

#　绑定地址
server_addr = ('127.0.0.1',8880)
sockfd.bind(server_addr)

#　收发消息
while True:
    data,addr = sockfd.recvfrom(1024)
    print("收到的消息:",data.decode())
    sockfd.sendto(b"Thanks",addr)

#　关闭套接字
sockfd.close()

客户端流程

代码实现：day2/udp_server.py
    1. 创建套接字
    2. 收发消息
    3. 关闭套接字
"""
udp套接字客户端
重点代码
"""

from socket import *

# 服务器地址
HOST = '127.0.0.1'
PORT = 8880
ADDR = (HOST,PORT)

# 创建套接字
sockfd = socket(AF_INET,SOCK_DGRAM)

#　收发消息
while True:
    data = input("Msg>>")
    if not data:
        break
    sockfd.sendto(data.encode(),ADDR)
    msg,addr = sockfd.recvfrom(1024)
    print("From server:",msg.decode())

sockfd.close()



总结 ：tcp套接字和udp套接字编程区别
    1. 流式套接字是以字节流方式传输数据，数据报套接字以数据报形式传输
    2. tcp套接字会有粘包，udp套接字有消息边界不会粘包
    3. tcp套接字保证消息的完整性，udp套接字则不能
    4. tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要
    5. tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom

socket模块方法和socket套接字属性
    1. 部分socket模块方法
        【1】 gethostname()  获取计算机名
        【2】 gethostbyname('www.baidu.com')  获取主机ip地址
        【3】 getservbyname('mysql') 获取服务端口号
        【4】 getservbyport(3306)  获取端口对应服务
        【5】 inet_aton('192.168.1.2') 将IP转换为bytes子串
        【6】 inet_ntoa(b'\xc0\xa8\x01\x02') 将bytes子串转换为IP地址
    2. 套接字属性
代码实现：day2/sock_attr.py
        【1】 sockfd.type  套接字类型
       
        【2】 sockfd.family 套接字地址类型
       
        【3】 sockfd.getsockname() 获取套接字绑定地址
       
        【4】 sockfd.fileno() 获取套接字的文件描述符
        
        【5】 sockfd.getpeername() 获取连接套接字客户端地址
        
        【6】 sockfd.setsockopt(level,option,value)
              功能：设置套接字选项
                               参数： level  选项类别   SOL_SOCKET
                                      option 具体选项内容
                                                        value  选项值
        
        【7】 sockfd.getsockopt(level,option) 
              功能 ： 获取套接字选项值
SOCKET ATTRIBUTES
from socket import *

# 　创建一个ｔｃｐ套接字
s = socket()

# 　设置套接字端口立即重用
s.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)

s.bind(("0.0.0.0", 8888))
s.listen(3)
c, addr = s.accept()
print("Connect:", addr)
c.recv(1024)

print("地址类型：", s.family)
print("套接字类型:", s.type)
print("绑定地址：", s.getsockname())
print("描述符:", s.fileno())
print("客户端地址:", c.getpeername())  # 连接套接字调用




作业 ： 1. 使用tcp服务和客户端编程，将一个文件从客户端发						 送到服务端，文件类型为图片或者普通文本皆可。

        2. 重点代码必须自己能写
UDP套接字广播
代码实现：day2/broadcast_recv.py
代码实现：day2/broadcast_recv.py
    • 广播定义 ： 一端发送多点接收
    • 广播地址 ： 每个网络的最大地址为发送广播的地址，向该地址发送，则网段内所有主机都能接收。
TCP套接字之HTTP传输
HTTP协议 （超文本传输协议）
    1. 用途 ： 网页获取，数据的传输
    2. 特点
    • 应用层协议，传输层使用tcp传输
    • 简单，灵活，很多语言都有HTTP专门接口
    • 无状态，协议不记录传输内容
    • http1.1 支持持久连接，丰富了请求类型
    3. 网页请求过程
1.客户端（浏览器）通过tcp传输，发送http请求给服务端
2.服务端接收到http请求后进行解析
3.服务端处理请求内容，组织响应内容
4.服务端将响应内容以http响应格式发送给浏览器
5.浏览器接收到响应内容，解析展示

HTTP请求
代码实现：day3/http_test.py
代码实现：day3/http_server.py
    • 请求行 ： 具体的请求类别和请求内容
        GET                  /                  HTTP/1.1
        请求类别   请求内容(主页）     协议版本
请求类别：每个请求类别表示要做不同的事情
                GET : 获取网络资源
                POST ：提交一定的信息，得到反馈
                HEAD ： 只获取网络资源的响应头
                PUT ： 更新服务器资源
                DELETE ： 删除服务器资源
                CONNECT
                TRACE ： 测试
                OPTIONS ： 获取服务器性能信息
    • 请求头：对请求的进一步解释和描述
Accept-Encoding: gzip
    • 空行
    • 请求体: 请求参数或者提交内容
http响应（response）
    1. 响应格式：响应行，响应头，空行，响应体
    • 响应行 ： 反馈基本的响应情况
HTTP/1.1     200       OK
版本信息    响应码   附加信息
响应码 ：
1xx  提示信息，表示请求被接收
2xx  响应成功
3xx  响应需要进一步操作，重定向
4xx  客户端错误
5xx  服务器错误
    • 响应头：对响应内容的描述
Content-Type: text/html
    • 响应体：响应的主体内容信息
struct模块的使用
代码实现：day3/struct_recv.py
代码实现：day3/struct_send.py
    1. 原理： 将一组简单数据进行打包，转换为bytes格式发送。或者将一组bytes格式数据，进行解析。
    2. 接口使用
Struct(fmt)
功能: 生成结构化对象
参数：fmt  定制的数据结构

st.pack(v1,v2,v3....)
功能: 将一组数据按照指定格式打包转换为bytes
参数：要打包的数据
返回值： bytes字节串

st.unpack(bytes_data)
功能： 将bytes字节串按照指定的格式解析
参数： 要解析的字节串
返回值： 解析后的内容

struct.pack(fmt,v1,v2,v3...)
struct.unpack(fmt,bytes_data)
说明： 可以使用struct模块直接调用pack unpack。此时这两函数第一个参数传入fmt。其他用法功能相同


